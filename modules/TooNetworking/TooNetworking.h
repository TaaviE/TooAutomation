/*
    TooNetworking - Networking abstraction layer for TooAutomation
    Copyright (C) 2017 Taavi E

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @file TooNetworking.h
 *
 * This file implements the necessary functionality
 * that allow nodes in the network to communicate
 */

#pragma once

#ifndef __TooNetworking_H__
/**
 * Header guard
 */
#define __TooNetworking_H__
#include <stdint.h>
#include <Arduino.h>

/**
 * **Reserved message header types**
 *
 * 
 * **System types** are 33-90 ('!'-A'-'Z'), they must not be used outside the library<br>
 * **User types** are 91-127 ('['-'a'-'z'-'DEL') and 1-32 ('^@'-' '), 1-32 are not acknowledged<br>
 *
 * @defgroup RESERVED_TYPES Reserved message header types by TooNetworking
 *
 * @{
 */

/**
 * Messages of this type contain nonces
 */
#define TOONETWORKING_NONCE 'A'

/**
 * Messages of this type are signed
 */
#define TOONETWORKING_SIGNED_MSG 'B'

/**
 * Messages of this type request nonces
 */
#define TOONETWORKING_NONCE_REQUEST 'C'

/**
 * Messages of this type are unused but reserved
 */
#define TOONETWORKING_UNUSED_2 'D'

/**
 * Messages of this type are signed and encrypted
 */
#define TOONETWORKING_ENCRYPTED_MSG 'E'

/** @} */

#ifdef TOONETWORKING_SIGNING
#include "sha256.h"

/**
 * Used for reading the required hash and payload size 
 * to properly deal with signed payloads
 */
typedef struct PayloadMetadataSigned {
  uint8_t payload_size; /**< Received payload size */
  uint8_t payload_hash[32]; /**< Payload hash generated by the source */
};

/**
 * Used for reading the required payload size 
 * to properly deal with the payloads
 */
typedef struct Payload_Metadata { // To simplify memory operations
  uint8_t payload_size; /**< Received payload size */
};

/**
 * Used for storing metadata about the payload until
 * the payload is sent
 */
typedef struct BufferItem { // Network buffer item
  uint8_t payload_size = 0; /**< Size of the payload pointed to by void * payload */
  uint8_t payload_hash[32] = {0}; /**< Storage of the hash generated */
  uint8_t payload_destination = 0; /**< Destination of the payload */
  BufferItem * payload_next = 0; /**< Next item in the list */
  void * payload = 0; /**< Pointer to the payload */
};

/**
 * Used for storing metadata and the nonce sent to
 * other nodes in the network
 */
typedef struct NonceSent {
  uint8_t nonce_to = 255;
  uint32_t nonce_time = 0;
  NonceSent * nonce_next = 0;
};

/**
 * Used for storing the nonce and metadata
 */
typedef struct NonceReceived {
  uint8_t nonce_from = 255;
  uint32_t nonce_time = 0;
  uint32_t nonce_timestamp = 0;
  NonceReceived * nonce_next = 0;
};

/**
 * Used to simplify sending nonce replies
 */
typedef struct NoncePayload {
  uint32_t nonce = 0;
};

/**
 * Used for storing metadata about nonce requests
 */
typedef struct NonceRequested {
  uint8_t nonce_from = 255;
  uint32_t nonce_request_first = 0;
  uint32_t nonce_request_last = 0;
  NonceRequested * nonce_next = 0;
};

Sha256Class Sha256;

NonceSent * nonce_sent_start = 0; /**< Pointer to the sent nonce list start */
NonceReceived * nonce_received_start = 0; /**< Pointer to the received nonce list start */
NonceRequested * nonce_requested_first = 0; /**< Pointer to the requested nonce list start */
BufferItem * buffer_first = 0; /**< Pointer to the payload list start */

#else

typedef struct Payload_Metadata { // Needed to calculate the size more easily and extract only the size from the entire payload
  uint8_t payload_size = 0;
};

typedef struct BufferItem { // Network buffer item
  uint8_t payload_size = 0;
  uint8_t payload_destination = 0;
  BufferItem * payload_next = 0;
  void * payload = 0;
};

BufferItem * buffer_first = 0; /**< Pointer to the payload list start */

#endif // TOONETWORKING_SIGNING


#ifdef TOORADIO_RF24

/*
* TODO:
* Send
* Send signed
* Send encrypted
* Send signed and encrypted
* Packets received
* Peek header but do not clear
* Read packet
* Connection available
*/

#include "RF24.h"
#include "RF24Mesh.h"
#include "RF24Network.h"


RF24 radio(TOO_RF24_CE, TOO_RF24_CS);
RF24Network network(radio);
RF24Mesh mesh(radio, network);


  /**
   * Automatically set up the networking, implementation depends on the radio
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool TooNetworking_connection_begin(uint8_t passed_node_id){
  mesh.setNodeID(passed_node_id);
  Serial.println(mesh.getNodeID());
  mesh.begin();
  Serial.println(F("Mesh initialized"));
}

  /**
   * Allows sending a encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send(uint8_t for_node, void * payload, uint8_t size, uint8_t type){
  return mesh.write(for_node, payload, type, size);
}

#ifdef TOONETWORKING_SIGNING
  /**
   * Allows sending a signed message, type must be embedded inside the payload
   * the receiver must know what to do with the message once it's been 
   * verified, messages that fail the checks are DISCARDED!
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed(uint8_t for_node, void * payload, uint8_t size){
  //Check if there's a nonce for that node
  //If there is send 

  //
}
#endif // TOONETWORKING_SIGNING

#ifdef TOONETWORKING_ENCRYPTION
  /**
   * Allows sending an encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TOONETWORKING_ENCRYPTION

#ifdef TOONETWORKING_ENCRYPTION && TOONETWORKING_SIGNING
  /**
   * Allows sending a signed and encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TOONETWORKING_ENCRYPTION && TOONETWORKING_SIGNING

  /**
   * Allows reading a message from buffer 
   * and it's NOT cleared after being read
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_peek(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Allows reading a message from buffer 
   * and it's cleared after being read
   * 
   * @param 
   * @return true if successful, false otherwise
   */
bool TooNetworking_read(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Checks if there's something ready to be processed
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_available(){
   return network.available();
}

  /**
   * Checks if the master node is reachable
   * 
   * @return true if successful, false otherwise
   */
bool TooNetworking_connection_check(){
   return mesh.checkConnection();
}

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_fix(){
   return mesh.renewAddress();
}

#ifdef TOONETWORKING_MASTER
  /**
   * Does the necessary maintenance and DHCP(-like) actions on the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_maintenance(){
   
}
#else
  /**
   * Does the necessary maintenance on the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_maintenance(){
   
}

#endif

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNeteorking_connection_fix(){
   return mesh.renewAddress();
}
#else  // TOORADIO_RF24
   #error "Networking library not selected"
#endif // No radio

  /**
   * Automatically set up the networking
   * Every radio should provide TooNetworking_connection_begin(uint8_t nodeID)
   * for easy initialization of the network
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool TooNetworking_begin(uint8_t passed_node_id){
  TooNetworking_connection_begin(passed_node_id);
}

#endif // __TooNetworking_H__