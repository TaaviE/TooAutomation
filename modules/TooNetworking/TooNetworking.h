/*
    TooNetworking - Networking abstraction layer for TooAutomation
    Copyright (C) 2017 Taavi E.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @file TooNetworking.h
 *
 * This file implements the necessary functionality
 * that allow nodes in the network to communicate
 */

#pragma once

#ifndef __TooNetworking_H__
#define __TooNetworking_H__

#include <stdint.h>
#include <Arduino.h>
#include "TooAutomation.h"

uint8_t current_node_ID;

#ifdef TooNetworking_SIGNING
#include "sha256.h"
#include "modules/TooSigning/TooSigning.h"
/**
 * Secret HMACs
 */
#include "configuration/hmacs.c"
#endif

/**
 * **Reserved message header types**
 *
 * 
 * **System types** are 33-90 ('!'-A'-'Z'), they must not be used outside the library<br>
 * **User types** that are acknowledged are 91-127 ('['-'a'-'z'-'DEL') and 1-32 ('^@'-' ') are not acknowledged<br>
 *
 * @defgroup TOONETWORKING_RESERVED_TYPES
 *
 * @{
 */

enum MessageTypes {
  MSG_NONCE = 'A', 
  MSG_SIGNED = 'B', 
  MSG_NONCE_REQUEST = 'C', 
  MSG_DUAL = 'D', 
  MSG_ENCRYPTED = 'E', 
};

/** @} */


/**
 * Used for storing metadata about the payload
 * until the payload is sent
 */
typedef struct BufferItem {
  uint8_t payload_size = 0;        /**< Size of the payload pointed to by void * payload */
  uint8_t payload_type = 0;        /**< Received payload type, to deal with messages signed, encrypted or both */ //TODO: Bit field
  uint8_t payload_destination = 0; /**< Destination of the payload */
  BufferItem * next = 0;           /**< Next item in the list */
  void * payload = 0;              /**< Pointer to the payload */
};

/**
 * Used for reading the required payload size 
 * to properly deal with the payloads
 * 
 * This is actually inside the sent and received
 * payloads unlike the rest of the data in BufferItem or BufferItem_Signed
 */
typedef struct Payload_Metadata_Received {
  uint8_t payload_size; /**< Received payload size */
  uint8_t payload_type; /**< Received payload type, to deal with messages signed, encrypted or both */
};


#ifdef TooNetworking_SIGNING

/**
 * Used for reading the required hash, payload type and size 
 * to properly deal with received signed payloads
 */
typedef struct Payload_MetadataSigned_Received {
  uint8_t payload_size;     /**< Received payload size */
  uint8_t payload_type;     /**< Received payload type, to deal with messages signed, encrypted or both */
  uint8_t payload_hash[32]; /**< Payload hash generated by the source */
};


/**
 * Used for storing metadata and the nonce sent to
 * other nodes in the network
 */
typedef struct NonceSent {
  uint8_t nonce_to = 255; /**< Destination           */
  uint32_t nonce = 0;     /**< Nonce itself          */
  NonceSent * next = 0;   /**< Next item in the list */
};

/**
 * Used for storing the nonce and metadata
 */
typedef struct NonceReceived {
  uint8_t nonce_from = 255; /**< Sender           */
  uint32_t nonce = 0;       /**< Nonce itself     */
  uint32_t noncestamp = 0;  /**< Destination      */
  NonceReceived * next = 0; /**< Next in the list */
};

/**
 * Used to simplify sending nonce replies
 */
typedef struct NoncePayload {
  uint32_t nonce = 0; /**< Nonce itself */
};

/**
 * Used for storing metadata about nonce requests
 */
typedef struct NonceRequested {
  uint8_t nonce_from = 255;         /**< Requested from     */
  uint32_t nonce_request_first = 0; /**< First request time */
  uint32_t nonce_request_last = 0;  /**< Last request time  */
  NonceRequested * next = 0;        /**< Next in the list   */
};

Sha256Class Sha256; /**< Hashing library object construction */

NonceSent * nonce_sent_start = 0;           /**< Pointer to the sent nonce list start */
NonceReceived * nonce_received_start = 0;   /**< Pointer to the received nonce list start */
NonceRequested * nonce_requested_first = 0; /**< Pointer to the requested nonce list start */


#endif

BufferItem * buffer_first = 0;              /**< Pointer to the payload list start */

#ifdef TOORADIO_RF24

/*
* TODO:
* Send signed
* Send encrypted
* Send signed and encrypted
* Packets received
* Peek header but do not clear
* Read packet
* Connection available 50%
*/

#include "RF24.h"
#include "RF24Mesh.h"
#include "RF24Network.h"

RF24 radio(TOO_RF24_CE, TOO_RF24_CS);
RF24Network network(radio);
RF24Mesh mesh(radio, network);

  /**
   * Automatically set up the networking, implementation depends on the radio
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_begin(uint8_t passed_node_id){
  mesh.setNodeID(passed_node_id);
  Serial.println(mesh.getNodeID());
  mesh.begin();
  Serial.println(F("Mesh initialized"));
}

  /**
   * Allows sending a encrypted message
   * 
   * @param identifier sets the used payload type, see TOONETWORKING_RESERVED_TYPES for more information
   * @param size payload size
   * @param for_node destination node
   * @param payload payload
   * @return true if successful, false otherwise
   */
bool TooNetworking_send(uint8_t for_node, void * payload, uint8_t size, uint8_t identifier){
  return mesh.write(for_node, payload, identifier, size);
}

#ifdef TooNetworking_SIGNING

  /**
   * Allows sending a signed message, type must be embedded inside the payload
   * the receiver must know what to do with the message once it's been 
   * verified, messages that fail the checks are DISCARDED!
   * 
   * @param for_node destination
   * @param payload payload
   * @param size size of payload
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed(uint8_t for_node, void * payload, uint8_t size){
  //Check if there's a nonce for that node
  uint32_t tempnonce = TooSigning_received_noncelist_find_from_ID(for_node);
  if(tempnonce != 0){
    TooNetworking_send_signed_(for_node, payload, size, tempnonce);
    return true;
  }

  //Else send nonce request
  TooSigning_requested_noncelist_add(for_node);

  //Store in buffer
  TooNetworking_bufferlist_add(for_node, payload, size, 1);
  return true;
}

  /**
   * Allows sending a signed message, type must be embedded inside the payload
   * the receiver must know what to do with the message once it's been 
   * verified, messages that fail the checks are DISCARDED!
   * 
   * @param for_node destination
   * @param payload payload
   * @param size size of payload
   * @param nonce nonce
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed_(uint8_t for_node, void * payload, uint8_t size, uint32_t nonce){
  if(TooNetworking_this_node_is_online()){
    Serial.println(F("Node is online"));
    if(TooNetworking_other_node_is_online()){
      Serial.println(F("Destination is online"));
      return true; //Message is sent, return
    }
    Serial.println(F("Destination is offline"));
  } else{
    Serial.println(F("This node is offline"));
    //TODO: Non-blocking fix connection
  }
}
#endif //TooNetworking_SIGNING

#ifdef TooNetworking_ENCRYPTION

  /**
   * Allows sending an encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TooNetworking_ENCRYPTION

#ifdef TooNetworking_ENCRYPTION && TooNetworking_SIGNING

  /**
   * Allows sending a signed and encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TooNetworking_ENCRYPTION && TooNetworking_SIGNING

  /**
   * Allows reading a message from buffer 
   * and it's NOT cleared after being read
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_peek(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Allows reading a message from buffer 
   * and it's cleared after being read
   * 
   * @param 
   * @return true if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_read(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Checks if there's something ready to be processed
   * 
   * @return True if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_available(){
   return network.available();
}

  /**
   * Checks if the master node is reachable
   * 
   * @return true if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_check(){
   return mesh.checkConnection();
}

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_fix(){
   return mesh.renewAddress();
}

#ifdef TooNetworking_MASTER
  /**
   * Does the necessary maintenance and DHCP(-like) actions on the network
   * 
   * @return True if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_maintenance(){
   
}
#else
  /**
   * Does the necessary maintenance on the network
   * 
   * @return True if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_maintenance(){
   
}
#endif

/**
 * **Regular message buffer list**
 *
 *
 * @defgroup TOONETWORKING_SIMPLE_BUFFER
 *
 * @{
 */


void TooNetworking_bufferlist_remove(const BufferItem * previous, const BufferItem * current) {
  Serial.println(F("Removing from buffer list"));
  if (current = buffer_first) { // Start of buffer list
    free(current->payload);
    free(current);
    buffer_first = NULL;
  } else if (current->next == NULL) { // First in the buffer list
    free(current->payload);
    free(current);
    previous->next = NULL;
  } else if (previous != NULL) { // Somehwere in the middle of the list
    previous->next = current->next;
    free(current->payload);
    free(current);
  } else {
    Serial.print(F("Error case not matched, dumping pointers: "));
    Serial.print((uint8_t) buffer_first);
    Serial.print(F(" "));
    Serial.print((uint8_t) previous);
    Serial.print(F(" "));
    Serial.print((uint8_t) previous->next);
    Serial.print(F(" "));
    Serial.print((uint8_t) current);
    Serial.print(F(" "));
    Serial.println((uint8_t) current->next);
  }
}

bool TooNetworking_bufferlist_initialize() {
  buffer_first = malloc(sizeof(BufferItem));
  Serial.println((uint8_t) buffer_first);
  if (buffer_first == NULL) {
    Serial.println(F("Buffer init failed"));
    return false;
  }

  (BufferItem)buffer_first->next = NULL;
  return true;
}

BufferItem * TooNetworking_bufferlist_find_for_id(uint8_t nodeID) {
  BufferItem * current = buffer_first;
  while (current != NULL) {
    if (current->payload_destination == nodeID) {
      return current;
    }
    current = current->next;
  }

  return NULL;
}

TooNetworking_bufferlist_send_(BufferItem current, BufferItem previous){
  if(TooNetworking_this_node_is_online()){
    if(TooNetworking_other_node_is_online()){
      
    }
  } else{
    //TODO: Non-blocking fix connection
  }
}


TooNetworking_bufferlist_add(uint8_t payload_destination, void * payload, uint8_t size, uint8_t type=0){
  Serial.println(F("Add item to buffer list"));
  BufferItem * current = (BufferItem)buffer_first;
  BufferItem * previous = NULL;
  if (buffer_first == 0) {
      if (!TooNetworking_bufferlist_initialize()) {
        return false;
      } else {
        current = buffer_first;
      }
    }
  } 
  
  while (current->next != NULL) {  //Take the last item in the list
    Serial.println(F("Finding the last item"));
    current = current->next;
  }
  
  previous = current;
  current = current->next;
  
  current->payload_destination = payload_destination;
  current->payload_size = size;
  current->payload_type = type;
  
  if(type == 0){
    if(TooNetworking_bufferlist_send_(current, previous)){
        return true;
    }
  } else {
    Serial.println(F("Finding nonce for nodeID"));
    NonceReceived * nonce = TooNetworking_received_noncelist_find_from_ID(payload_destination);
    
    if (nonce != 0) {
      TooNetworking_send_signed_(current, nonce, previous);
    } else { //TODO: Add encryption
      Serial.print(F("Adding pending nonce request... "));
      TooNetworking_requested_noncelist_add(payload_destination);
      Serial.println(F("Added"));
    }
  }
  
  Serial.println(F("Adding item to buffer list"));
  current->next = malloc(sizeof(BufferItem));
      
  if (current->next == NULL) {
    Serial.println(F("Failed to malloc"));
    return false;
  }
    
  Serial.println(F("Added item to buffer list"));
  return true;
}

bool TooNetworking_other_node_is_online(uint8_t nodeID){
  return true; //TODO
}

bool TooNetworking_this_node_is_online(){
  return true; //TODO
}

void TooNetworking_bufferlist_send_all() {
  BufferItem * current = (BufferItem) buffer_first;
  BufferItem * previous = 0;
  
  TooNetworking_bufferlist_print();
  Serial.println(F("Sending all: "));
  Serial.println((uint8_t) buffer_first);
  Serial.println((uint8_t) buffer_first->next);
  while (current != 0) {
    Serial.println(F("There's something in the buffer to send"));
    if(current->type == 0){
      TooNetworking_bufferlist_send(current, previous);
    } else{
     uint32_t nonce = TooNetworking_received_noncelist_find_from_ID(current->payload_destination);

     if (nonce != 0) {
       Serial.println(F(" ..one nonce for node is not 0!"));
       TooNetworking_send_signed(current, nonce, previous);
     }
    }
    previous = current;
    current = current->next;
  }
}

void TooNetworking_bufferlist_print() {
  Serial.println(F("___ BUFFER DUMP ___"));

  BufferItem * current = buffer_first;
  while (current != 0) {
    Serial.print(F("For: "));
    Serial.println(current->payload_destination);
    Serial.print(F("Pointer to next: "));
    Serial.println((uint16_t) current->next);
    Serial.print(F("Hash: "));
    NOTREVIEWED_TooNetworking_hash_print(current->hash);
    Serial.print(F("Payload size: "));
    Serial.println(current->payload_size);
    current = current->next;
  }
}
/** @} */

#ifdef NOTREVIEWED_TooNetworking_SIGNING



#endif

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_fix(){
   return mesh.renewAddress();
}


#else  // TOORADIO_RF24
   #error "Networking library not selected"
#endif // TOORADIO_RF24

  /**
   * Automatically set up the networking
   * Every radio should provide TooNetworking_connection_begin(uint8_t nodeID)
   * for easy initialization of the network
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_begin(uint8_t passed_node_id){
  NOTREVIEWED_TooNetworking_connection_begin(passed_node_id);
}

#endif // __NOTREVIEWED_TooNetworking_H__
