/*
    TooNetworking - Networking abstraction layer for TooAutomation
    Copyright (C) 2017 Taavi E.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @file TooNetworking.h
 *
 * This file implements the necessary functionality
 * that allow nodes in the network to communicate
 */

#pragma once

#ifndef __TooNetworking_H__
#define __TooNetworking_H__

#include <stdint.h>
#include <Arduino.h>
#include "TooAutomation.h"

uint8_t current_node_ID;

#ifdef TooNetworking_SIGNING
#include "sha256.h"
#include "modules/TooSigning/TooSigning.h"
/**
 * Secret HMACs
 */
#include "configuration/hmacs.c"
#endif

/**
 * **Reserved message header types**
 *
 * 
 * **System types** are 33-90 ('!'-A'-'Z'), they must not be used outside the library<br>
 * **User types** that are acknowledged are 91-127 ('['-'a'-'z'-'DEL') and 1-32 ('^@'-' ') are not acknowledged<br>
 *
 * @defgroup TooNetworking_RESERVED_TYPES
 *
 * @{
 */


/**
 * Messages of this type contain nonces
 */
#define TooNetworking_NONCE 'A'

/**
 * Messages of this type are signed
 */
#define TooNetworking_SIGNED_MSG 'B'

/**
 * Messages of this type request nonces
 */
#define TooNetworking_NONCE_REQUEST 'C'

/**
 * Messages of this type are unused but reserved
 */
#define TooNetworking_UNUSED_2 'D'

/**
 * Messages of this type are signed and encrypted
 */
#define TooNetworking_ENCRYPTED_MSG 'E'
/** @} */


/**
 * Used for storing metadata about the payload
 * until the payload is sent
 */
typedef struct BufferItem {
  uint8_t payload_size = 0;        /**< Size of the payload pointed to by void * payload */
  uint8_t payload_type = 0;        /**< Received payload type, to deal with messages signed, encrypted or both */
  void * next = 0;                 /**< Next item in the list */
  uint8_t payload_destination = 0; /**< Destination of the payload */
  void * payload = 0;              /**< Pointer to the payload */
};

/**
 * Used for reading the required payload size 
 * to properly deal with the payloads
 * 
 * This is actually inside the sent and received
 * payloads unlike the rest of the data in BufferItem or BufferItem_Signed
 */
typedef struct Payload_Metadata_Received {
  uint8_t payload_size; /**< Received payload size */
  uint8_t payload_type; /**< Received payload type, to deal with messages signed, encrypted or both */
};

/**
 * Used for reading the required payload size 
 * to properly deal with the payloads
 * 
 * This is NOT fully inside the sent and received payloads
 */
typedef struct Payload_Metadata_Buffered {
  uint8_t payload_size; /**< Received payload size */
  uint8_t payload_type; /**< Received payload type, to deal with messages signed, encrypted or both */
  void * next = 0;      /**< Next item in the list */
};


#ifdef TooNetworking_SIGNING

/**
 * Used for reading the required hash, payload type and size 
 * to properly deal with received signed payloads
 */
typedef struct Payload_MetadataSigned_Received {
  uint8_t payload_size;     /**< Received payload size */
  uint8_t payload_type;     /**< Received payload type, to deal with messages signed, encrypted or both */
  uint8_t payload_hash[32]; /**< Payload hash generated by the source */
};

/**
 * Used for reading the required hash, payload size and type
 * to properly deal with buffered signed payloads
 */
typedef struct Payload_MetadataSigned_Buffered {
  uint8_t payload_size;     /**< Received payload size */
  uint8_t payload_type;     /**< Received payload type, to deal with messages signed, encrypted or both */
  void * next = 0;          /**< Next item in the list */
};

/**
 * Used for storing metadata about the signed payload until
 * the payload is sent
 */
typedef struct BufferItem_Signed {
  uint8_t payload_size = 0;        /**< Size of the payload pointed to by void * payload */
  uint8_t payload_type = 0;        /**< Received payload type, to deal with messages signed, encrypted or both */
  void * next = 0;                 /**< Next item in the list */
  uint8_t payload_hash[32] = {0};  /**< Storage of the hash generated */
  uint8_t payload_destination = 0; /**< Destination of the payload */
  void * payload = 0;              /**< Pointer to the payload */
};


/**
 * Used for storing metadata and the nonce sent to
 * other nodes in the network
 */
typedef struct NonceSent {
  uint8_t nonce_to = 255; /**< Destination           */
  uint32_t nonce = 0;     /**< Nonce itself          */
  NonceSent * next = 0;   /**< Next item in the list */
};

/**
 * Used for storing the nonce and metadata
 */
typedef struct NonceReceived {
  uint8_t nonce_from = 255; /**< Sender           */
  uint32_t nonce = 0;       /**< Nonce itself     */
  uint32_t noncestamp = 0;  /**< Destination      */
  NonceReceived * next = 0; /**< Next in the list */
};

/**
 * Used to simplify sending nonce replies
 */
typedef struct NoncePayload {
  uint32_t nonce = 0; /**< Nonce itself */
};

/**
 * Used for storing metadata about nonce requests
 */
typedef struct NonceRequested {
  uint8_t nonce_from = 255;         /**< Requested from     */
  uint32_t nonce_request_first = 0; /**< First request time */
  uint32_t nonce_request_last = 0;  /**< Last request time  */
  NonceRequested * next = 0;        /**< Next in the list   */
};

Sha256Class Sha256; /**< Hashing library object construction */

NonceSent * nonce_sent_start = 0;           /**< Pointer to the sent nonce list start */
NonceReceived * nonce_received_start = 0;   /**< Pointer to the received nonce list start */
NonceRequested * nonce_requested_first = 0; /**< Pointer to the requested nonce list start */


#endif

void * buffer_first = 0;              /**< Pointer to the payload list start */

#ifdef TOORADIO_RF24

/*
* TODO:
* Send signed
* Send encrypted
* Send signed and encrypted
* Packets received
* Peek header but do not clear
* Read packet
* Connection available 50%
*/

#include "RF24.h"
#include "RF24Mesh.h"
#include "RF24Network.h"

RF24 radio(TOO_RF24_CE, TOO_RF24_CS);
RF24Network network(radio);
RF24Mesh mesh(radio, network);

  /**
   * Automatically set up the networking, implementation depends on the radio
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_connection_begin(uint8_t passed_node_id){
  mesh.setNodeID(passed_node_id);
  Serial.println(mesh.getNodeID());
  mesh.begin();
  Serial.println(F("Mesh initialized"));
}

  /**
   * Allows sending a encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_send(uint8_t for_node, void * payload, uint8_t size, uint8_t type){
  return mesh.write(for_node, payload, type, size);
}

#ifdef TooNetworking_SIGNING

  /**
   * Allows sending a signed message, type must be embedded inside the payload
   * the receiver must know what to do with the message once it's been 
   * verified, messages that fail the checks are DISCARDED!
   * 
   * @param for_node destination
   * @param payload payload
   * @param size size of payload
   * @return true if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_send_signed(uint8_t for_node, void * payload, uint8_t size){
  //Check if there's a nonce for that node
  uint32_t tempnonce = TooSigning_received_noncelist_find_from_ID(for_node);
  if(tempnonce != 0){
    TooNetworking_send_signed_(for_node, payload, size, tempnonce);
  }

  //Else send nonce request
  TooSigning_requested_noncelist_add(for_node);
  

  //Store in buffer
  TooNetworking_bufferlist_add(for_node, payload, size, 1);
}

  /**
   * Allows sending a signed message, type must be embedded inside the payload
   * the receiver must know what to do with the message once it's been 
   * verified, messages that fail the checks are DISCARDED!
   * 
   * @param for_node destination
   * @param payload payload
   * @param size size of payload
   * @param nonce nonce
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed_(uint8_t for_node, void * payload, uint8_t size, uint32_t nonce){

}
#endif //TooNetworking_SIGNING

#ifdef TooNetworking_ENCRYPTION

  /**
   * Allows sending an encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TooNetworking_ENCRYPTION

#ifdef TooNetworking_ENCRYPTION && TooNetworking_SIGNING

  /**
   * Allows sending a signed and encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_send_signed_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TooNetworking_ENCRYPTION && TooNetworking_SIGNING

  /**
   * Allows reading a message from buffer 
   * and it's NOT cleared after being read
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_peek(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Allows reading a message from buffer 
   * and it's cleared after being read
   * 
   * @param 
   * @return true if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_read(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Checks if there's something ready to be processed
   * 
   * @return True if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_connection_available(){
   return network.available();
}

  /**
   * Checks if the master node is reachable
   * 
   * @return true if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_connection_check(){
   return mesh.checkConnection();
}

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_connection_fix(){
   return mesh.renewAddress();
}

#ifdef UNCHECKED_TooNetworking_MASTER
  /**
   * Does the necessary maintenance and DHCP(-like) actions on the network
   * 
   * @return True if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_connection_maintenance(){
   
}
#else
  /**
   * Does the necessary maintenance on the network
   * 
   * @return True if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_connection_maintenance(){
   
}
#endif

/**
 * **Regular message buffer list**
 *
 *
 * @defgroup UNCHECKED_TooNetworking_SIMPLE_BUFFER
 *
 * @{
 */


void UNCHECKED_TooNetworking_bufferlist_remove(const void * previous, const void * current) {
  Serial.println(F("Removing from buffer list"));
  if (current = buffer_first) { // Start of buffer list
    free(current->payload);
    free(current);
    buffer_first = 0;
  } else if (current->next == 0) { // First in the buffer list
    free(current->payload);
    free(current);
    previous->next = 0;
  } else if (previous != 0) { // Somehwere in the middle of the list
    previous->next = current->next;
    free(current->payload);
    free(current);
  } else {
    Serial.print(F("Error case not matched, dumping pointers: "));
    Serial.print((uint8_t) buffer_first);
    Serial.print(F(" "));
    Serial.print((uint8_t) previous);
    Serial.print(F(" "));
    Serial.print((uint8_t) previous->next);
    Serial.print(F(" "));
    Serial.print((uint8_t) current);
    Serial.print(F(" "));
    Serial.println((uint8_t) current->next);
  }
}

bool UNCHECKED_TooNetworking_bufferlist_initialize() {
  buffer_first = malloc(sizeof(BufferItem));
  Serial.println((uint8_t) buffer_first);
  if (buffer_first == 0) {
    Serial.println(F("Buffer init failed"));
    return false;
  }

  buffer_first->next = 0;
  return true;
}

void * UNCHECKED_TooNetworking_bufferlist_find_for_id(uint8_t nodeID) {
  void * current = buffer_first;
  while (current != 0) {
    if (current->payload_destination == nodeID) {
      return current;
    }
    current = current->next;
    if (current == 0) {
      return NULL;
    }
  }

  return NULL;
}

bool UNCHECKED_TooNetworking_bufferlist_send(void * item, NonceReceived * nonce, void * previousitem) {
  Serial.println(F("Sending buffer item"));
  size_t sizeof_buffer = sizeof(Payload_Metadata) + item->payload_size; //Calculate the size of the message
  void * buf = malloc(sizeof_buffer); //Allocate enough memory for the buffer
  Serial.print(F("Metadata size: "));
  Serial.println((uint8_t) sizeof(Payload_Metadata));
  Serial.print(F("Payload size: "));
  Serial.println((uint8_t) item->payload_size);
  Serial.print(F("Buffer size: "));
  Serial.println((uint8_t) sizeof_buffer);
  Serial.print(F("Buffer address: "));
  Serial.println((uint8_t) buf);

  Serial.print(F("From: "));
  Serial.println(current_node_ID);
  Serial.print(F("To: "));
  Serial.println(item->payload_destination);

  uint8_t hmac[20] = {0};
  UNCHECKED_TooNetworking_read_hmac_from_progmem(current_node_ID, &hmac);
  if (hmac[0] == hmacs[0][0]) {
    Serial.println(F("Equal"));
  }

  Serial.print(F("HMAC: "));
  Serial.println(hmac[0], DEC);
  Serial.println(hmacs[0][0], DEC);
  Serial.println(hmacs[1][0], DEC);

  for (int i; i > 20; i++) {
    Serial.print(hmac[i]);
  }
  Serial.println();

  Sha256.initHmac(hmac, 20); //Initialize the hmac
  Serial.print(F("Size of full payload: "));
  Serial.println(item->payload_size);

  UNCHECKED_TooNetworking_hash_data(item->payload, item->payload_size); //Hash the data itself
  Serial.print(F("Nonce: "));
  Serial.println(nonce->nonce);

  UNCHECKED_TooNetworking_hash_data(&(nonce->nonce), sizeof(uint32_t));
  UNCHECKED_TooNetworking_hash_store(Sha256.resultHmac(), item->hash); //Store hash in payload hash

  //Serial.print(F("Memmove 1: "));
  //Serial.println((uint8_t)
  memmove(buf, item, sizeof(Payload_Metadata)); //Copy metadata to the start of the buffer

  Serial.print(F("Metadata: "));
  UNCHECKED_TooNetworking_random_data_print(buf, sizeof(Payload_Metadata));

  //Serial.print(F("Memmove 2: "));
  //Serial.println((uint8_t)
  memmove(buf + sizeof(Payload_Metadata), item->payload, item->payload_size); //Copy the payload to the end of the buffer

  Serial.print(F("Full buffer: "));
  UNCHECKED_TooNetworking_random_data_print(buf, sizeof(Payload_Metadata) + item->payload_size);

  Serial.print(F("Generated hash: "));
  UNCHECKED_TooNetworking_hash_print(item->hash);

  bool state = mesh.write(buf, 'S', sizeof_buffer, item->payload_destination); //Send the message
  Serial.print(F("I guess it's "));
  Serial.println(state ? F("sent") : F("not sent"));
  if (state) { //Remove if sent
    Serial.println(F("Removing sent message"));
    UNCHECKED_TooNetworking_bufferlist_remove(previousitem, item);
  }
  Serial.println(F("Buffer list"));
  UNCHECKED_TooNetworking_bufferlist_print();
  Serial.println(F("Buffer list printed"));
  delay(1000);
}

bool UNCHECKED_TooNetworking_bufferlist_add(uint8_t payload_destination, void * payload, uint8_t size, uint8_t type=0) {
  Serial.println(F("Add item to buffer list"));
  Serial.println(size);
  void * current = buffer_first;
  void * previous = 0;
  if (buffer_first == 0) {
    if(!type){
      if (!TooNetworking_bufferlist_initialize()) {
        return false;
      } else {
        current = buffer_first;
      }
    } else if(type == 1){ //TODO: Exclude if signing is not enabled
      if(!TooNetworking_bufferlist_initialize_signed(){
          return false;
        } else{
          current = buffer_first;
        }
      }
    } //TODO: Add encryption support
  } else {
    
    while (current->next != 0) {  //Take the last item in the list
      Serial.println(F("Finding the last item"));
      current = current->next;
    }

    current->next = malloc(sizeof(NonceReceived));
    if (current->next == 0) {
      Serial.println(F("Failed to malloc"));
      return false;
    }
    previous = current;
    current = current->next;
  }

  current->payload_destination = payload_destination;
  current->payload = payload;
  current->payload_size = size;

  Serial.println(F("Finding nonce for nodeID"));
  NonceReceived * nonce = UNCHECKED_TooNetworking_received_noncelist_find_from_ID(payload_destination);
  if (nonce != 0) {
    UNCHECKED_TooNetworking_bufferlist_send(current, nonce, previous);
    return true;
  } else {
    Serial.println(F("Requested nonce"));
    UNCHECKED_TooNetworking_requested_noncelist_add(payload_destination);
    Serial.println(F("Requested"));
  }
  Serial.println(F("Added item to buffer list"));
  return true;
}

void UNCHECKED_TooNetworking_bufferlist_send_all() {
  BufferItem * current = buffer_first;
  BufferItem * previous = 0;
  UNCHECKED_TooNetworking_bufferlist_print();
  Serial.println(F("Sending all: "));
  Serial.println((uint8_t) buffer_first);
  Serial.println((uint8_t) buffer_first->next);
  while (current != 0) {
    Serial.println(F("There's something in the buffer to send"));
    uint32_t nonce = UNCHECKED_TooNetworking_received_noncelist_find_from_ID(current->payload_destination);

    if (nonce != 0) {
      Serial.println(F(" ..one nonce for node is not 0!"));
      UNCHECKED_TooNetworking_bufferlist_send(current, nonce, previous);
    }
    previous = current;
    current = current->next;
  }
}

void UNCHECKED_TooNetworking_bufferlist_print() {
  Serial.println(F("___ BUFFER DUMP ___"));

  BufferItem * current = buffer_first;
  while (current != 0) {
    Serial.print(F("For: "));
    Serial.println(current->payload_destination);
    Serial.print(F("Pointer to next: "));
    Serial.println((uint16_t) current->next);
    Serial.print(F("Hash: "));
    UNCHECKED_TooNetworking_hash_print(current->hash);
    Serial.print(F("Payload size: "));
    Serial.println(current->payload_size);
    current = current->next;
  }
}
/** @} */

#ifdef UNCHECKED_TooNetworking_SIGNING



#endif

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_connection_fix(){
   return mesh.renewAddress();
}


#else  // TOORADIO_RF24
   #error "Networking library not selected"
#endif // TOORADIO_RF24

  /**
   * Automatically set up the networking
   * Every radio should provide UNCHECKED_TooNetworking_connection_begin(uint8_t nodeID)
   * for easy initialization of the network
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool UNCHECKED_TooNetworking_begin(uint8_t passed_node_id){
  UNCHECKED_TooNetworking_connection_begin(passed_node_id);
}

#endif // __UNCHECKED_TooNetworking_H__
