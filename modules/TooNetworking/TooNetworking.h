/*
    TooNetworking - Networking abstraction layer for TooAutomation
    Copyright (C) 2017 Taavi E

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @file TooNetworking.h
 *
 * This file implements the necessary functionality
 * that allow nodes in the network to communicate
 */

#pragma once

#ifndef __TooNetworking_H__
/**
 * Header guard
 */
#define __TooNetworking_H__
#include <stdint.h>
#include <Arduino.h>

/**
 * **Reserved message header types**
 *
 * 
 * **System types** are 33-90 ('!'-A'-'Z'), they must not be used outside the library<br>
 * **User types** are 91-127 ('['-'a'-'z'-'DEL') and 1-32 ('^@'-' '), 1-32 are not acknowledged<br>
 *
 * @defgroup RESERVED_TYPES Reserved message header types by TooNetworking
 *
 * @{
 */

/**
 * Messages of this type contain nonces
 */
#define TOONETWORKING_NONCE 'A'

/**
 * Messages of this type are signed
 */
#define TOONETWORKING_SIGNED_MSG 'B'

/**
 * Messages of this type request nonces
 */
#define TOONETWORKING_NONCE_REQUEST 'C'

/**
 * Messages of this type are unused but reserved
 */
#define TOONETWORKING_UNUSED_2 'D'

/**
 * Messages of this type are signed and encrypted
 */
#define TOONETWORKING_ENCRYPTED_MSG 'E'

/** @} */

#ifdef TOONETWORKING_SIGNING
#include "sha256.h"

/**
 * Used for reading the required hash and payload size 
 * to properly deal with signed payloads
 */
typedef struct PayloadMetadataSigned {
  uint8_t payload_size; /**< Received payload size */
  uint8_t payload_hash[32]; /**< Payload hash generated by the source */
};

/**
 * Used for reading the required payload size 
 * to properly deal with the payloads
 */
typedef struct Payload_Metadata { // To simplify memory operations
  uint8_t payload_size; /**< Received payload size */
};

/**
 * Used for storing metadata about the payload until
 * the payload is sent
 */
typedef struct BufferItem { // Network buffer item
  uint8_t payload_size = 0; /**< Size of the payload pointed to by void * payload */
  uint8_t payload_hash[32] = {0}; /**< Storage of the hash generated */
  uint8_t payload_destination = 0; /**< Destination of the payload */
  BufferItem * payload_next = 0; /**< Next item in the list */
  void * payload = 0; /**< Pointer to the payload */
};

/**
 * Used for storing metadata and the nonce sent to
 * other nodes in the network
 */
typedef struct NonceSent {
  uint8_t nonce_to = 255;
  uint32_t nonce_time = 0;
  NonceSent * nonce_next = 0;
};

/**
 * Used for storing the nonce and metadata
 */
typedef struct NonceReceived {
  uint8_t nonce_from = 255;
  uint32_t nonce_time = 0;
  uint32_t nonce_timestamp = 0;
  NonceReceived * nonce_next = 0;
};

/**
 * Used to simplify sending nonce replies
 */
typedef struct NoncePayload {
  uint32_t nonce = 0;
};

/**
 * Used for storing metadata about nonce requests
 */
typedef struct NonceRequested {
  uint8_t nonce_from = 255;
  uint32_t nonce_request_first = 0;
  uint32_t nonce_request_last = 0;
  NonceRequested * nonce_next = 0;
};

Sha256Class Sha256;

NonceSent * nonce_sent_start = 0; /**< Pointer to the sent nonce list start */
NonceReceived * nonce_received_start = 0; /**< Pointer to the received nonce list start */
NonceRequested * nonce_requested_first = 0; /**< Pointer to the requested nonce list start */
BufferItem * buffer_first = 0; /**< Pointer to the payload list start */

#else

typedef struct Payload_Metadata { // Needed to calculate the size more easily and extract only the size from the entire payload
  uint8_t payload_size = 0;
};

typedef struct BufferItem { // Network buffer item
  uint8_t payload_size = 0;
  uint8_t payload_destination = 0;
  BufferItem * payload_next = 0;
  void * payload = 0;
};

BufferItem * buffer_first = 0; /**< Pointer to the payload list start */

#endif // TOONETWORKING_SIGNING



#ifdef TOORADIO_RF24

/*
* TODO:
* Send signed
* Send encrypted
* Send signed and encrypted
* Packets received
* Peek header but do not clear
* Read packet
* Connection available 50%
*/

#include "RF24.h"
#include "RF24Mesh.h"
#include "RF24Network.h"


RF24 radio(TOO_RF24_CE, TOO_RF24_CS);
RF24Network network(radio);
RF24Mesh mesh(radio, network);

  /**
   * Automatically set up the networking, implementation depends on the radio
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool TooNetworking_connection_begin(uint8_t passed_node_id){
  mesh.setNodeID(passed_node_id);
  Serial.println(mesh.getNodeID());
  mesh.begin();
  Serial.println(F("Mesh initialized"));
}

  /**
   * Allows sending a encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send(uint8_t for_node, void * payload, uint8_t size, uint8_t type){
  return mesh.write(for_node, payload, type, size);
}

#ifdef TOONETWORKING_SIGNING

  /**
   * Allows sending a signed message, type must be embedded inside the payload
   * the receiver must know what to do with the message once it's been 
   * verified, messages that fail the checks are DISCARDED!
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed(uint8_t for_node, void * payload, uint8_t size){
  //Check if there's a nonce for that node
  //If there is, sign it, send it
  //Else send nonce request
  //Store in buffer
}
#endif // TOONETWORKING_SIGNING

#ifdef TOONETWORKING_ENCRYPTION

  /**
   * Allows sending an encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TOONETWORKING_ENCRYPTION

#ifdef TOONETWORKING_ENCRYPTION && TOONETWORKING_SIGNING

  /**
   * Allows sending a signed and encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TOONETWORKING_ENCRYPTION && TOONETWORKING_SIGNING

  /**
   * Allows reading a message from buffer 
   * and it's NOT cleared after being read
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_peek(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Allows reading a message from buffer 
   * and it's cleared after being read
   * 
   * @param 
   * @return true if successful, false otherwise
   */
bool TooNetworking_read(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Checks if there's something ready to be processed
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_available(){
   return network.available();
}

  /**
   * Checks if the master node is reachable
   * 
   * @return true if successful, false otherwise
   */
bool TooNetworking_connection_check(){
   return mesh.checkConnection();
}

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_fix(){
   return mesh.renewAddress();
}

#ifdef TOONETWORKING_MASTER
  /**
   * Does the necessary maintenance and DHCP(-like) actions on the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_maintenance(){
   
}
#else
  /**
   * Does the necessary maintenance on the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_maintenance(){
   
}
#endif

void TooSigning_bufferlist_remove(BufferListItem * previous, BufferListItem * current) {
  Serial.println(F("Removing from buffer list"));
  if (current = rfsigned.bufferlist_first) { // Start of buffer list
    free(current->payload);
    free(current);
    rfsigned.bufferlist_first = 0;
  } else if (current->next == 0) { // First in the buffer list
    free(current->payload);
    free(current);
    previous->next = 0;
  } else if (previous != 0) { // Somehwere in the middle of the list
    previous->next = current->next;
    free(current->payload);
    free(current);
  } else {
    Serial.print(F("Error case not matched, dumping pointers: "));
    Serial.print((uint8_t) rfsigned.bufferlist_first);
    Serial.print(F(" "));
    Serial.print((uint8_t) previous);
    Serial.print(F(" "));
    Serial.print((uint8_t) previous->next);
    Serial.print(F(" "));
    Serial.print((uint8_t) current);
    Serial.print(F(" "));
    Serial.println((uint8_t) current->next);
  }
}

/*
  Sending buffer related functions
*/
bool TooSigning_bufferlist_initialize() {
  rfsigned.bufferlist_first = malloc(sizeof(BufferListItem));
  Serial.println((uint8_t) rfsigned.bufferlist_first);
  if (rfsigned.bufferlist_first == 0) {
    Serial.println(F("Buffer init failed"));
    return false;
  }

  rfsigned.bufferlist_first->next = 0;
  return true;
}

BufferListItem * TooSigning_bufferlist_find_for_id(uint8_t nodeID) {
  BufferListItem * current = rfsigned.bufferlist_first;
  while (current != 0) {
    if (current->BufferListItemForNode == nodeID) {
      return current;
    }
    current = current->next;
    if (current == 0) {
      return NULL;
    }
  }

  return NULL;
}

bool TooSigning_bufferlist_send(BufferListItem * item, ReceivedNonce * nonce, BufferListItem * previousitem) {
  Serial.println(F("Sending buffer item"));
  size_t sizeof_buffer = sizeof(PayloadMetadata) + item->payload_size; //Calculate the size of the message
  void * buf = malloc(sizeof_buffer); //Allocate enough memory for the buffer
  Serial.print(F("Metadata size: "));
  Serial.println((uint8_t) sizeof(PayloadMetadata));
  Serial.print(F("Payload size: "));
  Serial.println((uint8_t) item->payload_size);
  Serial.print(F("Buffer size: "));
  Serial.println((uint8_t) sizeof_buffer);
  Serial.print(F("Buffer address: "));
  Serial.println((uint8_t) buf);

  Serial.print(F("From: "));
  Serial.println(rfsigned.current_node_ID);
  Serial.print(F("To: "));
  Serial.println(item->BufferListItemForNode);

  uint8_t hmac[20] = {0};
  TooSigning_read_hmac_from_progmem(rfsigned.current_node_ID, &hmac);
  if (hmac[0] == hmacs[0][0]) {
    Serial.println(F("Equal"));
  }

  Serial.print(F("HMAC: "));
  Serial.println(hmac[0], DEC);
  Serial.println(hmacs[0][0], DEC);
  Serial.println(hmacs[1][0], DEC);

  for (int i; i > 20; i++) {
    Serial.print(hmac[i]);
  }
  Serial.println();

  rfsigned.Sha256.initHmac(hmac, 20); //Initialize the hmac
  Serial.print(F("Size of full payload: "));
  Serial.println(item->payload_size);

  TooSigning_hash_data(item->payload, item->payload_size); //Hash the data itself
  Serial.print(F("Nonce: "));
  Serial.println(nonce->nonce);

  TooSigning_hash_data(&(nonce->nonce), sizeof(uint32_t));
  TooSigning_hash_store(rfsigned.Sha256.resultHmac(), item->hash); //Store hash in payload hash

  //Serial.print(F("Memmove 1: "));
  //Serial.println((uint8_t)
  memmove(buf, item, sizeof(PayloadMetadata)); //Copy metadata to the start of the buffer

  Serial.print(F("Metadata: "));
  TooSigning_random_data_print(buf, sizeof(PayloadMetadata));

  //Serial.print(F("Memmove 2: "));
  //Serial.println((uint8_t)
  memmove(buf + sizeof(PayloadMetadata), item->payload, item->payload_size); //Copy the payload to the end of the buffer

  Serial.print(F("Full buffer: "));
  TooSigning_random_data_print(buf, sizeof(PayloadMetadata) + item->payload_size);

  Serial.print(F("Generated hash: "));
  TooSigning_hash_print(item->hash);

  bool state = mesh.write(buf, 'S', sizeof_buffer, item->BufferListItemForNode); //Send the message
  Serial.print(F("I guess it's "));
  Serial.println(state ? F("sent") : F("not sent"));
  if (state) { //Remove if sent
    Serial.println(F("Removing sent message"));
    TooSigning_bufferlist_remove(previousitem, item);
  }
  Serial.println(F("Buffer list"));
  TooSigning_bufferlist_print();
  Serial.println(F("Buffer list printed"));
  delay(1000);
}


bool TooSigning_bufferlist_add(uint8_t BufferListItemForNode, void * payload, uint8_t size) {
  Serial.println(F("Add item to buffer list"));
  Serial.println(size);
  BufferListItem * current = rfsigned.bufferlist_first;
  BufferListItem * previous = 0;
  if (rfsigned.bufferlist_first == 0) {
    if (!TooSigning_bufferlist_initialize()) {
      return false;
    } else {
      current = rfsigned.bufferlist_first;
    }
  } else {
    while (current->next != 0) {  //Take the last item in the list
      Serial.println(F("Finding the last item"));
      current = current->next;
    }

    current->next = malloc(sizeof(ReceivedNonce));
    if (current->next == 0) {
      Serial.println(F("Failed to malloc"));
      return false;
    }
    previous = current;
    current = current->next;
  }

  current->BufferListItemForNode = BufferListItemForNode;
  current->payload = payload;
  current->payload_size = size;

  Serial.println(F("Finding nonce for nodeID"));
  ReceivedNonce * nonce = TooSigning_received_noncelist_find_from_ID(BufferListItemForNode);
  if (nonce != 0) {
    TooSigning_bufferlist_send(current, nonce, previous);
    return true;
  } else {
    Serial.println(F("Requested nonce"));
    TooSigning_requested_noncelist_add(BufferListItemForNode);
    Serial.println(F("Requested"));
  }
  Serial.println(F("Added item to buffer list"));
  return true;
}

void TooSigning_bufferlist_send_all() {
  BufferListItem * current = rfsigned.bufferlist_first;
  BufferListItem * previous = 0;
  TooSigning_bufferlist_print();
  Serial.println(F("Sending all: "));
  Serial.println((uint8_t) rfsigned.bufferlist_first);
  Serial.println((uint8_t) rfsigned.bufferlist_first->next);
  while (current != 0) {
    Serial.println(F("There's something in the buffer to send"));
    uint32_t nonce = TooSigning_received_noncelist_find_from_ID(current->BufferListItemForNode);

    if (nonce != 0) {
      Serial.println(F(" ..one nonce for node is not 0!"));
      TooSigning_bufferlist_send(current, nonce, previous);
    }
    previous = current;
    current = current->next;
  }
}

void TooSigning_bufferlist_print() {
  Serial.println(F("___ BUFFER DUMP ___"));

  BufferListItem * current = rfsigned.bufferlist_first;
  while (current != 0) {
    Serial.print(F("For: "));
    Serial.println(current->BufferListItemForNode);
    Serial.print(F("Pointer to next: "));
    Serial.println((uint16_t) current->next);
    Serial.print(F("Hash: "));
    TooSigning_hash_print(current->hash);
    Serial.print(F("Payload size: "));
    Serial.println(current->payload_size);
    current = current->next;
  }
}
  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNeteorking_connection_fix(){
   return mesh.renewAddress();
}
#else  // TOORADIO_RF24
   #error "Networking library not selected"
#endif // No radio

  /**
   * Automatically set up the networking
   * Every radio should provide TooNetworking_connection_begin(uint8_t nodeID)
   * for easy initialization of the network
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool TooNetworking_begin(uint8_t passed_node_id){
  TooNetworking_connection_begin(passed_node_id);
}

#endif // __TooNetworking_H__