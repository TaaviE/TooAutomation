/*
    TooNetworking - Networking abstraction layer for TooAutomation
    Copyright (C) 2017 Taavi E.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @file TooNetworking.h
 *
 * This file implements the necessary functionality
 * that allow nodes in the network to communicate
 */

#pragma once

#ifndef __TooNetworking_H__
#define __TooNetworking_H__

#include <stdint.h>
#include <Arduino.h>
#include "TooAutomation.h"

uint8_t current_node_ID;

#ifdef TooNetworking_SIGNING
#include "sha256.h"
#include "modules/TooSigning/TooSigning.h"
#include "modules/TooNetworking/TooNetworking_data.h"


#ifdef TOONETWORKING_SIGNING
#include "modules/TooSigning/TooSigning.h"
#include "sha256.h"
Sha256Class Sha256; /**< Hashing library object construction */

/**
 * Secret HMACs
 */
#include "configuration/hmacs.c"
#endif

/**
 * **Reserved message header types**
 *
 * 
 * **System types** are 33-90 ('!'-A'-'Z'), they must not be used outside the library<br>
 * **User types** that are acknowledged are 91-127 ('['-'a'-'z'-'DEL') and 1-32 ('^@'-' ') are not acknowledged<br>
 *
 * @defgroup TOONETWORKING_RESERVED_TYPES
 *
 * @{
 */

enum MessageTypes {
  MSG_NONCE = 'A', 
  MSG_SIGNED = 'B', 
  MSG_NONCE_REQUEST = 'C', 
  MSG_DUAL = 'D', 
  MSG_ENCRYPTED = 'E', 
};

/** @} */


/**
 * Used for storing metadata about the payload
 * until the payload is sent
 */
typedef struct BufferItem {
  uint8_t payload_size = 0;        /**< Size of the payload pointed to by void * payload */
  uint8_t payload_type = 0;        /**< Received payload type, to deal with messages signed, encrypted or both */ //TODO: Bit field
  uint8_t payload_destination = 0; /**< Destination of the payload */
  BufferItem * next = 0;           /**< Next item in the list */
  void * payload = 0;              /**< Pointer to the payload */
};

/**
 * Used for reading the required payload size 
 * to properly deal with the payloads
 * 
 * This is actually inside the sent and received
 * payloads unlike the rest of the data in BufferItem or BufferItem_Signed
 */
typedef struct Payload_Metadata_Received {
  uint8_t payload_size; /**< Received payload size */
  uint8_t payload_type; /**< Received payload type, to deal with messages signed, encrypted or both */
};


#ifdef TooNetworking_SIGNING

/**
 * Used for reading the required hash, payload type and size 
 * to properly deal with received signed payloads
 */
typedef struct Payload_MetadataSigned_Received {
  uint8_t payload_size;     /**< Received payload size */
  uint8_t payload_type;     /**< Received payload type, to deal with messages signed, encrypted or both */
  uint8_t payload_hash[32]; /**< Payload hash generated by the source */
};


/**
 * Used for storing metadata and the nonce sent to
 * other nodes in the network
 */
typedef struct NonceSent {
  uint8_t nonce_to = 255; /**< Destination           */
  uint32_t nonce = 0;     /**< Nonce itself          */
  NonceSent * next = 0;   /**< Next item in the list */
};

/**
 * Used for storing the nonce and metadata
 */
typedef struct NonceReceived {
  uint8_t nonce_from = 255; /**< Sender           */
  uint32_t nonce = 0;       /**< Nonce itself     */
  uint32_t noncestamp = 0;  /**< Destination      */
  NonceReceived * next = 0; /**< Next in the list */
};

/**
 * Used to simplify sending nonce replies
 */
typedef struct NoncePayload {
  uint32_t nonce = 0; /**< Nonce itself */
};

/**
 * Used for storing metadata about nonce requests
 */
typedef struct NonceRequested {
  uint8_t nonce_from = 255;         /**< Requested from     */
  uint32_t nonce_request_first = 0; /**< First request time */
  uint32_t nonce_request_last = 0;  /**< Last request time  */
  NonceRequested * next = 0;        /**< Next in the list   */
};

Sha256Class Sha256; /**< Hashing library object construction */

NonceSent * nonce_sent_start = 0;           /**< Pointer to the sent nonce list start */
NonceReceived * nonce_received_start = 0;   /**< Pointer to the received nonce list start */
NonceRequested * nonce_requested_first = 0; /**< Pointer to the requested nonce list start */


#endif

BufferItem * buffer_first = 0;              /**< Pointer to the payload list start */

#ifdef TOORADIO_RF24

#endif // TOONETWORKING_SIGNING

uint8_t current_node_ID;
BufferItem * buffer_first = 0;              /**< Pointer to the payload list start */

/*
* TODO:
* Send signed
* Send encrypted
* Send signed and encrypted
* Packets received
* Peek header but do not clear
* Read packet
* Connection available 50%
*/

#include "RF24.h"
#include "RF24Mesh.h"
#include "RF24Network.h"

RF24 radio(TOO_RF24_CE, TOO_RF24_CS);
RF24Network network(radio);
RF24Mesh mesh(radio, network);

  /**
   * Automatically set up the networking, implementation depends on the radio
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */
bool TooNetworking_connection_begin(uint8_t passed_node_id){
  mesh.setNodeID(passed_node_id);
  Serial.println(mesh.getNodeID());
  mesh.begin();
  Serial.println(F("Mesh initialized"));
}

#ifdef TOONETWORKING_SIGNING
  //TooSigning_signed_network_begin(passed_node_id);
#endif // TOONETWORKING_SIGNING

#ifdef TOONETWORKING_ENCRYPTION
  //TODO: Init encryption
#endif // TOONETWORKING_SIGNING
}

  /**
   * Allows sending a encrypted message
   * 
   * @param identifier sets the used payload type, see TOONETWORKING_RESERVED_TYPES for more information
   * @param size payload size
   * @param for_node destination node
   * @param payload payload
   * @return true if successful, false otherwise
   */
bool TooNetworking_send(uint8_t for_node, void * payload, uint8_t size, uint8_t identifier){
  return mesh.write(for_node, payload, identifier, size);
}

#ifdef TooNetworking_SIGNING

  /**
   * Allows sending a signed message, type must be embedded inside the payload
   * the receiver must know what to do with the message once it's been 
   * verified, messages that fail the checks are DISCARDED!
   * 
   * @param for_node destination
   * @param payload payload
   * @param size size of payload
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed(uint8_t for_node, void * payload, uint8_t size){
  //Check if there's a nonce for that node
  uint32_t tempnonce = TooSigning_received_noncelist_find_from_ID(for_node);
  if(tempnonce != 0){
    TooNetworking_send_signed_(for_node, payload, size, tempnonce);
    return true;
  }

  //Else send nonce request
  TooSigning_requested_noncelist_add(for_node);

  //Store in buffer
  TooNetworking_bufferlist_add(for_node, payload, size, 1);
  return true;
}

  /**
   * Allows sending a signed message, type must be embedded inside the payload
   * the receiver must know what to do with the message once it's been 
   * verified, messages that fail the checks are DISCARDED!
   * 
   * @param for_node destination
   * @param payload payload
   * @param size size of payload
   * @param nonce nonce
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed_(uint8_t for_node, void * payload, uint8_t size, uint32_t nonce){
  if(TooNetworking_this_node_is_online()){
    Serial.println(F("Node is online"));
    if(TooNetworking_other_node_is_online()){
      Serial.println(F("Destination is online"));
      return true; //Message is sent, return
    }
    Serial.println(F("Destination is offline"));
  } else{
    Serial.println(F("This node is offline"));
    //TODO: Non-blocking fix connection
  }
}
#endif //TooNetworking_SIGNING

#ifdef TooNetworking_ENCRYPTION

  /**
   * Allows sending an encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TooNetworking_ENCRYPTION

#ifdef TooNetworking_ENCRYPTION && TooNetworking_SIGNING

  /**
   * Allows sending a signed and encrypted message
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signed_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TooNetworking_ENCRYPTION && TooNetworking_SIGNING

  /**
   * Allows reading a message from buffer 
   * and it's NOT cleared after being read
   * 
   * @param
   * @return true if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_peek(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Allows reading a message from buffer 
   * and it's cleared after being read
   * 
   * @param 
   * @return true if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_read(RF24NetworkHeader& header, void* message, uint16_t maxlen){

}

  /**
   * Checks if there's something ready to be processed
   * 
   * @return True if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_available(){
   return network.available();
}

  /**
   * Checks if the master node is reachable
   * 
   * @return true if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_check(){
   return mesh.checkConnection();
}

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_fix(){
   return mesh.renewAddress();
}

#ifdef TooNetworking_MASTER
  /**
   * Does the necessary maintenance and DHCP(-like) actions on the network
   * 
   * @return True if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_maintenance(){
   
}
#else
  /**
   * Does the necessary maintenance on the network
   * 
   * @return True if successful, false otherwise
   */
bool NOTREVIEWED_TooNetworking_connection_maintenance(){
   
}
#endif
/**
 * Allows reading a message from buffer
 * and it's NOT cleared after being read
 *
 * @param
 */
void TooNetworking_peek(RF24NetworkHeader& header, void* message, uint16_t maxlen){
  network.peek(header, message, maxlen);
}

/**
 * Allows reading a message from buffer
 * and it's cleared after being read
 *
 * @param
 * @return true if successful, false otherwise
 */
bool TooNetworking_read(RF24NetworkHeader& header, void* message, uint16_t maxlen){
  return network.read(header, message, maxlen);
}

/**
 * Checks if there's something ready to be processed
 *
 * @return True if successful, false otherwise
 */
bool TooNetworking_connection_available(){
  return network.available();
}

/**
 * Checks if the master node is reachable
 *
 * @return true if successful, false otherwise
 */
bool TooNetworking_connection_check(){
  return mesh.checkConnection();
}

/**
 * Tries to reestablish connection to the network
 *
 * @return True if successful, false otherwise
 */
bool TooNetworking_connection_fix(){
  if(!TooNetworking_connection_available()){
    return mesh.renewAddress();
  }
}

/**
 * **Regular message buffer list**
 *
 *
 * @defgroup TOONETWORKING_SIMPLE_BUFFER
 *
 * @{
 */

void TooNetworking_bufferlist_print() {
  Serial.println(F("___ BUFFER DUMP ___"));

  BufferItem * current = buffer_first;
  while (current != 0) {
    Serial.print(F("For: "));
    Serial.println(current->payload_destination);
    Serial.print(F("Pointer to next: "));
    Serial.println((uint16_t) current->next);
    Serial.print(F("Payload size: "));
    Serial.println(current->payload_size);
    current = current->next;
  }
}

void TooNetworking_bufferlist_remove(BufferItem * previous, BufferItem * current) {
  Serial.println(F("Removing from buffer list"));
  if (current = buffer_first) { // Start of buffer list
    free(current->payload);
    free(current);
    buffer_first = NULL;
  } else if (current->next == NULL) { // First in the buffer list
    free(current->payload);
    free(current);
    previous->next = NULL;
  } else if (previous != NULL) { // Somehwere in the middle of the list
    previous->next = current->next;
    free(current->payload);
    free(current);
  } else {
    Serial.print(F("Error case not matched, dumping pointers: "));
    Serial.print((uint8_t) buffer_first);
    Serial.print(F(" "));
    Serial.print((uint8_t) previous);
    Serial.print(F(" "));
    Serial.print((uint8_t) previous->next);
    Serial.print(F(" "));
    Serial.print((uint8_t) current);
    Serial.print(F(" "));
    Serial.println((uint8_t) current->next);
  }
}

bool TooNetworking_bufferlist_initialize() {
  buffer_first = malloc(sizeof(BufferItem));
  Serial.println((uint8_t) buffer_first);
  if (buffer_first == NULL) {
    Serial.println(F("Buffer init failed"));
    return false;
  }

  (BufferItem)buffer_first->next = NULL;

  buffer_first->next = NULL;
  return true;
}

BufferItem * TooNetworking_bufferlist_find_for_id(uint8_t nodeID) {
  BufferItem * current = buffer_first;
  while (current != NULL) {
    if (current->payload_destination == nodeID) {
      return current;
    }
    current = current->next;
  }

  return NULL;
}

TooNetworking_bufferlist_send_(BufferItem current, BufferItem previous){
  if(TooNetworking_this_node_is_online()){
    if(TooNetworking_other_node_is_online()){
      
    }
  } else{
    //TODO: Non-blocking fix connection
  }
}


TooNetworking_bufferlist_add(uint8_t payload_destination, void * payload, uint8_t size, uint8_t type=0){
  Serial.println(F("Add item to buffer list"));
  BufferItem * current = (BufferItem)buffer_first;
  BufferItem * previous = NULL;
  if (buffer_first == 0) {
      if (!TooNetworking_bufferlist_initialize()) {
        return false;
      } else {
        current = buffer_first;
      }
    }
  } 
  
  while (current->next != NULL) {  //Take the last item in the list
=======

  return NULL;
}

bool TooNetworking_bufferlist_send_(BufferItem * current, BufferItem * previous){
  if(TooNetworking_connection_available()){
    if(TooNetworking_connection_other_available(current->payload_destination)){
      size_t buffer_size = current->payload_size+sizeof(Payload_Metadata_Received);
      void * buffer = malloc(buffer_size);
      memmove(buffer, current, sizeof(Payload_Metadata_Received)); //Copy metadata to buffer
      memmove(buffer+sizeof(Payload_Metadata_Received), current->payload, current->payload_size); //Copy payload to buffer after metadata

      if(TooNetworking_send(current->payload_destination, buffer, buffer_size, MSG_HEADER_REGULAR)){
        TooNetworking_bufferlist_remove(current, previous);
        return true;
      } else{
        return false;
      }
    } else{
      return false;
    }
  } else{
    //TODO: Non-blocking fix connection
    return false;
  }
}

/**
 * Adds message that the system couldn't send instantly to the buffer
 *
 * */
void TooNetworking_bufferlist_add(uint8_t payload_destination, void * payload, uint8_t size, uint8_t type=MSG_HEADER_REGULAR){
  Serial.println(F("Add item to buffer list"));
  BufferItem * current = buffer_first;
  BufferItem * previous = NULL;
  if (buffer_first == 0) {
    if (!TooNetworking_bufferlist_initialize()) {
      return false;
    } else {
      current = buffer_first;
    }
  }

  while ((current->next) != NULL) {  //Take the last item in the list
    Serial.println(F("Finding the last item"));
    current = current->next;
  }
  
  previous = current;
  current->next = malloc(sizeof(BufferItem)); //TODO: Safe malloc (enough room and error handling)
  current = current->next;
  
  current->payload_destination = payload_destination;
  current->payload_size = size;
  current->payload_type = type;
  
  if(type == 0){
    if(TooNetworking_bufferlist_send_(current, previous)){
        return true;
    }
  } else {
    Serial.println(F("Finding nonce for nodeID"));
    NonceReceived * nonce = TooNetworking_received_noncelist_find_from_ID(payload_destination);
    
    if (nonce != 0) {
      TooNetworking_send_signed_(current, nonce, previous);
    } else { //TODO: Add encryption
      Serial.print(F("Adding pending nonce request... "));
      TooNetworking_requested_noncelist_add(payload_destination);
      Serial.println(F("Added"));
    }
  }
  
  Serial.println(F("Adding item to buffer list"));
  current->next = malloc(sizeof(BufferItem));
      
  if (current->next == NULL) {
    Serial.println(F("Failed to malloc"));
    return false;
  }
    
  Serial.println(F("Added item to buffer list"));
  return true;
}

bool TooNetworking_other_node_is_online(uint8_t nodeID){
  return true; //TODO
}

bool TooNetworking_this_node_is_online(){
  return true; //TODO
}

void TooNetworking_bufferlist_send_all() {
  BufferItem * current = (BufferItem) buffer_first;

/** @} */

#ifdef TOONETWORKING_SIGNING

/**
 * Allows sending a signed message, type must be embedded inside the payload
 * the receiver must know what to do with the message once it's been
 * verified, messages that fail the checks are DISCARDED!
 *
 * @param for_node destination
 * @param payload payload
 * @param size size of payload
 * @param nonce nonce
 * @return true if successful, false otherwise
 */
bool TooNetworking_send_signed(uint8_t for_node, void * payload, uint8_t size, uint32_t nonce){
  if(TooNetworking_connection_available()){
    Serial.println(F("Node is online"));
    if(TooNetworking_connection_other_available(for_node)){
      Serial.println(F("Destination is online"));

      size_t buffer_size = size+sizeof(Payload_MetadataSigned_Received);
      void * buffer = malloc(buffer_size);
      Payload_MetadataSigned_Received metadata;
      metadata.payload_size = size;
      metadata.payload_type = MSG_HEADER_SIGNED;
      //Payload signing process start
      uint8_t hmac[20] = {0};
      TooSigning_read_hmac_from_progmem(for_node, &hmac);

      Serial.println(F("HMAC used: "));
      for (int i; i > 20; i++) {
        Serial.print(hmac[i]);
      }
      Serial.println();
      Sha256.initHmac(hmac, 20);

      TooSigning_random_data_print(payload, size);
      TooSigning_hash_data(payload, size);
      TooSigning_hash_data(&nonce, sizeof(uint32_t));
      TooSigning_hash_store(Sha256.resultHmac(), metadata.payload_hash);
      //Payload signing process end
      //To buffer, from metadata, with the size of metadata
      memmove(buffer, &metadata, sizeof(Payload_MetadataSigned_Received)); //Copy metadata to buffer
      //To buffer with an offset, from payload, with the size of payload
      memmove(buffer+sizeof(Payload_Metadata_Received), payload, size); //Copy payload to buffer after metadata

      if(TooNetworking_send(for_node, buffer, buffer_size, MSG_HEADER_REGULAR)){
        return true;
      }
    }
    Serial.println(F("Destination is offline"));
  } else{
    Serial.println(F("This node is offline"));
    //TODO: Non-blocking fix connection
  }
}

/**
 * Allows sending a signed message, type must be embedded inside the payload
 * the receiver must know what to do with the message once it's been
 * verified, messages that fail the checks are DISCARDED!
 *
 * @param for_node destination
 * @param payload payload
 * @param size size of payload
 * @return true if successful, false otherwise
 */
bool TooNetworking_bufferlist_send_signed(uint8_t for_node, void * payload, uint8_t size){
  //Check if there's a nonce for that node
  uint32_t tempnonce = TooSigning_received_noncelist_find_from_ID(for_node);
  if(tempnonce != 0){
    if(TooNetworking_send_signed(for_node, payload, size, tempnonce)){
      //Message hasn't made it to the buffer list
      return true;
    }
  }

  //Else send nonce request
  TooSigning_requested_noncelist_add(for_node);

  //Store in buffer
  TooNetworking_bufferlist_add(for_node, payload, size, MSG_HEADER_SIGNED);
  return true;
}

#endif //TOONETWORKING_SIGNING


#ifdef TOONETWORKING_ENCRYPTION
  /**
   * Allows sending an encrypted message
   *
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_encrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TOONETWORKING_ENCRYPTION

#ifdef TOONETWORKING_ENCRYPTION && TOONETWORKING_SIGNING

  /**
   * Allows sending a signed and encrypted message
   *
   * @param
   * @return true if successful, false otherwise
   */
bool TooNetworking_send_signedencrypted(uint8_t for_node, void * payload, uint8_t size){

}
#endif // TOONETWORKING_ENCRYPTION && TOONETWORKING_SIGNING

void TooNetworking_bufferlist_send_all() {
  BufferItem * current = buffer_first;
>>>>>>> 79802c3552a474864d89f4624aab2bf93c584e89
  BufferItem * previous = 0;
  
  TooNetworking_bufferlist_print();
  Serial.println(F("Sending all: "));
  Serial.println((uint8_t) buffer_first);
  Serial.println((uint8_t) buffer_first->next);
  while (current != 0) {
    Serial.println(F("There's something in the buffer to send"));
    if(current->type == 0){
      TooNetworking_bufferlist_send(current, previous);
    } else{
     uint32_t nonce = TooNetworking_received_noncelist_find_from_ID(current->payload_destination);

     if (nonce != 0) {
       Serial.println(F(" ..one nonce for node is not 0!"));
       TooNetworking_send_signed(current, nonce, previous);
     }
    }

    if(current->payload_type == MSG_HEADER_REGULAR){
      if(TooNetworking_bufferlist_send_(current, previous)){
        TooNetworking_bufferlist_remove(current, previous);
      }
    }
    #ifdef TOONETWORKING_SIGNING
    else if(current->payload_type == MSG_HEADER_SIGNED){
      uint32_t nonce = TooSigning_received_noncelist_find_from_ID(current->payload_destination);

      if (nonce != 0) {
        Serial.println(F(" ..one nonce for node is not 0!"));
        if(TooNetworking_send_signed(current->payload_destination, current->payload, current->payload_size, nonce)){
          //Message was sent, might as well remove it
          TooNetworking_bufferlist_remove(previous, current);
        }
      }
    }
    #endif
    previous = current;
    current = current->next;
  }
}

void TooNetworking_bufferlist_print() {
  Serial.println(F("___ BUFFER DUMP ___"));

  BufferItem * current = buffer_first;
  while (current != 0) {
    Serial.print(F("For: "));
    Serial.println(current->payload_destination);
    Serial.print(F("Pointer to next: "));
    Serial.println((uint16_t) current->next);
    Serial.print(F("Hash: "));
    NOTREVIEWED_TooNetworking_hash_print(current->hash);
    Serial.print(F("Payload size: "));
    Serial.println(current->payload_size);
    current = current->next;
  }
}
/** @} */

#ifdef NOTREVIEWED_TooNetworking_SIGNING



#endif

  /**
   * Tries to reestablish connection to the network
   * 
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_fix(){
   return mesh.renewAddress();
}
  /**
   * Does the necessary master node
   * maintenance and DHCP(-like) actions on the network
   *
   * @return True if successful, false otherwise
   */
bool TooNetworking_connection_maintenance(){
#ifdef TOONETWORKING_MASTER
  mesh.DHCP();
#endif // TOONETWORKING_MASTER

#ifdef TOONETWORKING_SIGNING
  //TooSigning_signed_network_begin(20);
  TooSigning_signed_network_update();
#endif // TOONETWORKING_SIGNING

  mesh.update();
}


#else  // TOORADIO_RF24
   #error "Networking library not selected"
#endif // TOORADIO_RF24

  /**
   * Automatically set up the networking
   * Every radio should provide TooNetworking_connection_begin(uint8_t nodeID)
   * for easy initialization of the network
   * 
   * @param passed_node_id Current node's ID.
   * @return true if successful, false otherwise
   */

  bool TooNetworking_begin(uint8_t passed_node_id) {
      TooNetworking_connection_begin(passed_node_id);
  }

/**
 * Error out when preprocessor flags are with the wrong
 * capitalization to save debugging time
 *
 */
#ifdef TooNetworking_SIGNING
#error "Define TOONETWORKING_SIGNING instead!"
#endif

#ifdef TooNetworking_MASTER
#error "Define TOONETWORKING_MASTER instead!"
#endif

#ifdef TooRadio_RF24
#error "Define TOORADIO_RF24 instead!"
#endif

#endif // __TooNetworking_H__

